/*

  ******************************************************************************
  * @file 			( фаил ):   MAX7219.c
  * @brief 		( описание ):  	Матрица 8 на 8 индикация ( N количество )
  ******************************************************************************
  * @attention 	( внимание ):	author: Golinskiy Konstantin	e-mail: golinskiy.konstantin@gmail.com
  ******************************************************************************
  
*/

/* Includes ----------------------------------------------------------*/

#include "MAX7219.h"
#include "font.h"


uint8_t frameBuffer[MATRIXS_QUANTITY*8];	// массив для буфера кадра на размер матрицы

int32_t x = 0;   // координата X
int32_t y = 0;	// координата Y


/*
	******************************************************************************
	* @brief	 ( описание ):  Записывает в массив указаные координаты
	* @param	( параметры ):	координата Х и У
	* @return  ( возвращает ):	указатель на символ
	******************************************************************************
*/
uint8_t* _getBufferPtr(int16_t x, int16_t y)
{
	if ((y < 0) || (y >= 8))
		return NULL;
	if ((x < 0) || (x >= (8*MATRIXS_QUANTITY)))
		return NULL;

	uint16_t B = x >> 3;		//byte

	return frameBuffer + y*MATRIXS_QUANTITY + B;
}
//--------------------------------------------------------------------------------


/*
	******************************************************************************
	* @brief	 ( описание ):  Рисует указаный пиксель на матрице
	* @param	( параметры ):	координата Х и У и значения пикселя 1 или 0 ( 1-вкл    0-выкл )
	* @return  ( возвращает ):	
	******************************************************************************
*/
void setPixel(int16_t x, int16_t y, uint8_t enabled)
{
	uint8_t* p = _getBufferPtr(x, y);
	if (!p)
		return;

	uint16_t b = 7 - (x & 7);		//bit

	if (enabled)
		*p |=  (1<<b);
	else
		*p &= ~(1<<b);
}
//--------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  Узнать состояния указаного пикселя
	* @param	( параметры ):	координата Х и У
	* @return  ( возвращает ):	значения пикселя 1 или 0 ( 1-вкл    0-выкл )
	******************************************************************************
*/
uint8_t getPixel(int16_t x, int16_t y)
{
	uint8_t* p = _getBufferPtr(x, y);
	if (!p)
		return 0;

	uint16_t b = 7 - (x & 7);		//bit

	return *p & (1 << b);
}
//--------------------------------------------------------------------------------


/*
	******************************************************************************
	* @brief	 ( описание ):  Рисует символ или картинку
	* @param	( параметры ):	координата Х и У ( начало символа и размер символа
	* @return  ( возвращает ):	
	******************************************************************************
*/
void drawSprite( const uint8_t* sprite, int x, int y, int width, int height )
{
  // The mask is used to get the column bit from the sprite row
  uint8_t mask = 0x80;

  for( int iy = 0; iy < height; iy++ )
  {
    for( int ix = 0; ix < width; ix++ )
    {
      setPixel(x + ix, y + iy, (uint8_t)(sprite[iy] & mask ));

      // shift the mask by one pixel to the right
      mask = mask >> 1;
    }

    // reset column mask
    mask = 0x80;
  }
}
//---------------------------------------------------------------------------------  
  
/*
	******************************************************************************
	* @brief	 ( описание ):  Рисует бегущую строку
	* @param	( параметры ):	ссылка на массив с символами ( сама строка )
								координата Х и У ( начало прорисовки строки )
	* @return  ( возвращает ):	
	******************************************************************************
*/ 
void drawString( char* text, int x, int y ){
  uint16_t len = strlen(text);
		
  uint16_t count_len =0;
	
  while( len-- ){

	count_len++;  
    uint8_t c;
	
	//---------------------------------------------------------------------
		// проверка на кириллицу UTF-8, если латиница то пропускаем if
		// Расширенные символы ASCII Win-1251 кириллица (код символа 128-255)
		// проверяем первый байт из двух ( так как UTF-8 ето два байта )
		// если он больше либо равен 0xC0 ( первый байт в кириллеце будет равен 0xD0 либо 0xD1 именно в алфавите )
		if ( (uint8_t)*text >= 0xC0 ){	// код 0xC0 соответствует символу кириллица 'A' по ASCII Win-1251
			
			// проверяем какой именно байт первый 0xD0 либо 0xD1
			switch ((uint8_t)*text) {
				case 0xD0: {
					// увеличиваем массив так как нам нужен второй байт
					text++;
					// проверяем второй байт там сам символ
					if ((uint8_t)*text == 0x81) { c = 0xA8; break; }		// байт символа Ё ( если нужнф еще символы добавляем тут и в функции DrawChar() )
					if ((uint8_t)*text >= 0x90 && (uint8_t)*text <= 0xBF){ c = (*text) + 0x30; }	// байт символов А...Я а...п  делаем здвиг на +48
					break;
				}
				case 0xD1: {
					// увеличиваем массив так как нам нужен второй байт
					text++;
					// проверяем второй байт там сам символ
					if ((uint8_t)*text == 0x91) { c = 0xB8; break; }		// байт символа ё ( если нужнф еще символы добавляем тут и в функции DrawChar() )
					if ((uint8_t)*text >= 0x80 && (uint8_t)*text <= 0x8F){ c = (*text) + 0x70; }	// байт символов п...я	елаем здвиг на +112
					break;
				}
			}
		}
		else{
			c = *text;
		}
		
		text++;
	//---------------------------------------------------------------------
	  
	  // номер по ASCII - позиция в массиве  = значение которое нужно отнять
	  
	  // символы латинские буквы цифры и спецсимволы начинаються с - 32 символ по ASCII а в массиве 0 эллемент
	  // значит 32 - 0 = 32 значит от текущего значения отнимаем 32
	  // и делаем это для всего латинского алфавита ( так как в массиве он идет по таблице ASCII )
	  // то для всего диапазона ( от 32 до 127 включительно отнимаем 32 )
	  // проверяем диапазон  для латинских символов и немного спец символов 
	  if( c > 31 && c < 128 ){
		  c = c - 32;
	  }
	  
	  // символ кирилица А - 192 символ по ASCII а в массиве 96 эллемент
	  // значит 192 - 96 = 96 значит от текущего значения отнимаем 96
	  // и делаем это для всей килилицы алфавита ( так как в массиве он идет по таблице ASCII )
	  // то для всего диапазона ( от 192 до 255 включительно отнимаем 96 )
	  // проверяем диапазон  для латинских символов и немного спец символов 
	  else  if( c > 191 ){
		  c = c - 96;
	  }
	  
	  // дополнительные символы и знаки если нужны
	  // добавляем в конец массива тут делаем проверку и расчеты
	  // номер по ASCII - позиция в массиве  = значение которое нужно отнять
	  else if( c == 168 ){ c = c - 8; }		    // 168 - 160 эллемент массива ( символ Ё ) = 8
	  else if( c == 184 ){ c = c - 23; }		// 184 - 161 эллемент массива ( символ ё ) = 23
	  
	  
    // stop if char is outside visible area
    if( x + count_len * 8  > ( MATRIXS_QUANTITY*8 ) ){
      return;
	}
	
    // only draw if char is visible
    if( 8 + x + count_len * 8 > 0 ){
      drawSprite( disp1ay[c], x + count_len * 8, y, 8, 8 );
	}
  }
}
//----------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  реверсирует передаваимый байт
	* @param	( параметры ):	1 байт
	* @return  ( возвращает ):	
	******************************************************************************
*/
static void reverse(uint8_t *b) {
   *b = (*b & 0xF0) >> 4 | (*b & 0x0F) << 4;
   *b = (*b & 0xCC) >> 2 | (*b & 0x33) << 2;
   *b = (*b & 0xAA) >> 1 | (*b & 0x55) << 1;
}
//------------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  фуекция передачи побитово 1 байт информации
	* @param	( параметры ):	1 байт информации для передачи в матрицу
	* @return  ( возвращает ):	
	******************************************************************************
*/
void write_byte(uint8_t byte){
	for(int i=0;i<8;i++)
          {
			GPIO_CLK( GPIO_LOW );  // Pull the CLK LOW
			GPIO_DIN((byte&0x80) ? GPIO_HIGH : GPIO_LOW );// Write one BIT data MSB first
            byte = byte<<1;  // shift the data to the left
            GPIO_CLK( GPIO_HIGH );   // Pull the CLK HIGH
          }
}
//-------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  фуекция вкл или выкл матрицы
	* @param	( параметры ):	1 или 0 ( 1-вкл    0-выкл )
	* @return  ( возвращает ):	
	******************************************************************************
*/
void setEnabled(uint8_t enabled)
{
	GPIO_CS( GPIO_LOW );   // включаем на порту CS уровень LOW
	for( uint8_t i = MATRIXS_QUANTITY; i; i--){
		write_byte( 0x0C );   //  write address
		write_byte( 0x00 | (enabled ? 1: 0) );  //  write data
	}
    GPIO_CS( GPIO_HIGH );  // включаем на порту CS уровень HIGH	
}
//---------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  фуекция яркости подсветки
	* @param	( параметры ):	яркость от 0 до 15
	* @return  ( возвращает ):	
	******************************************************************************
 * level:
 * 	0 - lowest (1/32)
 * 15 - highest (31/32)
 */
void setIntensity(uint8_t level)
{
	//maximum intensity is 0xF;
	if (level > 0xF) level = 0xF;	
	
	GPIO_CS( GPIO_LOW );   // включаем на порту CS уровень LOW
	for( uint8_t i = MATRIXS_QUANTITY; i; i--){
		write_byte( 0x0A );   //  write address
		write_byte( 0x00 | level );  //  write data
	}
    GPIO_CS( GPIO_HIGH );  // включаем на порту CS уровень HIGH	
}
//--------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  фуекция отправки 2 байта информации на дисплей
	* @param	( параметры ):	данные 2 байта
	* @return  ( возвращает ):	
	******************************************************************************
*/
void _displayRow(uint8_t row)
{
	//calculates row address based on flags
	uint8_t address_row = 0 & 4 ? 7 - row: row;

	uint8_t display_x_inverted = 0 & 2;
	uint8_t segment_x_inverted = 0 & 1;

	//for x inverted display change iterating order
	//inverting segments may still be needed!
	int16_t from = display_x_inverted ? MATRIXS_QUANTITY-1:  0;		//start from ...
	int16_t to =   display_x_inverted ? -1  : MATRIXS_QUANTITY;		//where to stop
	int16_t step = display_x_inverted ? -1 :  1;		//directon

	GPIO_CS( GPIO_LOW );   // включаем на порту CS уровень LOW

	for (int16_t d = from; d != to; d += step)
	{
		uint8_t data = frameBuffer[d + row*MATRIXS_QUANTITY];
		if (segment_x_inverted)
			reverse(&data);
		uint16_t cmd = ((address_row + 1) << 8) | data;
		for(int i=0;i<16;i++)
          {
			GPIO_CLK( GPIO_LOW );  // Pull the CLK LOW
			GPIO_DIN(( cmd & 0x8000 ) ? GPIO_HIGH : GPIO_LOW );// Write one BIT data MSB first
            cmd = cmd<<1;  // shift the data to the left
            GPIO_CLK( GPIO_HIGH );  // Pull the CLK HIGH
          }
	}

	GPIO_CS( GPIO_HIGH );  // включаем на порту CS уровень HIGH
	
}
//-----------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  фуекция отображения переданной ранее информации на дисплее
	* @param	( параметры ):	
	* @return  ( возвращает ):	
	******************************************************************************
*/
void display(void)
{
	for (uint8_t y = 0; y < 8; y++)
	{
		_displayRow(y);
	}
}
//-----------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  фуекция отчистки массива где храниться информация для отображения
	* @param	( параметры ):	
	* @return  ( возвращает ):	
	******************************************************************************
*/
void clear(void) {
	memset(frameBuffer, 0, 8*MATRIXS_QUANTITY);
}
//---------------------------------------------------------------------------------

/*
	******************************************************************************
* @brief	 ( описание ):  функция аналогичная setPixel
	* @param	( параметры ):	координата Х
								значение для отображения
	* @return  ( возвращает ):	
	******************************************************************************
*/
void setColumn(int16_t x, uint8_t value)
{
	//no need to check x, will be checked by setPixel
	for (uint8_t y = 0; y < 8; ++y)
	{
		setPixel(x, y, value & 1);
		value >>= 1;
	}
}
//--------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  для семи сигментного индикатора показывает цифру в указаном индекаторе
	* @param	( параметры ):	номер дисплея ( 7 сегментный только )
								значение для отображения ( цифра )
								1 или 0 показывать ли точку
	* @return  ( возвращает ):	
	******************************************************************************
 * Sets a digit to the specified value.
 * Digits are numbered 0..(8*N-1).
 * Digits 0..7 are in the first controller, digits 8..15 in the next, etc.
 */
void setDigit(uint16_t digit, uint8_t value, uint8_t dot)
{
	if (digit >= (8*MATRIXS_QUANTITY))
		return;

	// The frameBuffer is organized as 8 rows of N bytes.
	uint8_t row = digit & 7;
	uint8_t controller = digit >> 3;

	frameBuffer[row * MATRIXS_QUANTITY + controller] = value | (dot ? 1<<7 : 0);
}
//-----------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  функция инициализации матриц ( несколько матриц )
	* @param	( параметры ):	
	* @return  ( возвращает ):	
	******************************************************************************
*/
void MAX_init (void)
{	
	GPIO_CS( GPIO_LOW );   // включаем на порту CS уровень LOW
	for( uint8_t i = MATRIXS_QUANTITY; i; i--){
		//  режим без декодирования пишем биты напрямую
		write_byte(0x09);   //  write address
		write_byte(0x00);  //  write data
	}
	GPIO_CS( GPIO_HIGH );  // включаем на порту CS уровень HIGH
	
	GPIO_CS( GPIO_LOW );   // включаем на порту CS уровень LOW
	for( uint8_t i = MATRIXS_QUANTITY; i; i--){
		//  подсветка значения первые 4 бита  ( получаеться от 0x00 до 0x0F ) ысего 16 значений
		write_byte(0x0A);   //  write address
		write_byte(0x03);  //  write data
	}
	GPIO_CS( GPIO_HIGH );  // включаем на порту CS уровень HIGH
	
	GPIO_CS( GPIO_LOW );   // включаем на порту CS уровень LOW
	for( uint8_t i = MATRIXS_QUANTITY; i; i--){
		//  сколько светодиодов будет сканироваться максимум 8
		write_byte(0x0B);   //  write address
		write_byte(0x07);  //  write data
	}
	GPIO_CS( GPIO_HIGH );  // включаем на порту CS уровень HIGH
	
	GPIO_CS( GPIO_LOW );   // включаем на порту CS уровень LOW
	for( uint8_t i = MATRIXS_QUANTITY; i; i--){
		//  отключить ( 0x00 ) и включить( 0x01 ) дисплей
		write_byte(0x0C);   //  write address
		write_byte(0x01);  //  write data
	}
	GPIO_CS( GPIO_HIGH );  // включаем на порту CS уровень HIGH
	
	GPIO_CS( GPIO_LOW );   // включаем на порту CS уровень LOW
	for( uint8_t i = MATRIXS_QUANTITY; i; i--){
		//  режим теста віключен
		write_byte(0x0F);   //  write address
		write_byte(0x00);  //  write data
	}
    GPIO_CS( GPIO_HIGH );  // включаем на порту CS уровень HIGH
}
//----------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  функция подсчета длины строки с учетом кириллицы ( 2 байта на символ )
	* @param	( параметры ):	
	* @return  ( возвращает ):	

	******************************************************************************
*/
uint16_t strlenUTF8( char* str ){
	uint16_t i = 0;
	while( *str != '\0' ){
		if( (uint8_t)*str >= 0xC0 ){	// код 0xC0 соответствует символу кириллица 'A' по ASCII Win-1251
			str++;
		}
		
		i++;
		str++;
	}
	return i;
}
//----------------------------------------------------------------------------------


/************************ (C) COPYRIGHT GKP *****END OF FILE****/
